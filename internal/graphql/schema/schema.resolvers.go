package schema

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	initializers "github.com/Zenithive/it-crm-backend/Initializers"
	"github.com/Zenithive/it-crm-backend/auth"
	"github.com/Zenithive/it-crm-backend/internal/graphql/generated"
	"github.com/Zenithive/it-crm-backend/models"
	"github.com/Zenithive/it-crm-backend/utils"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*generated.AuthPayload, error) {
	var user models.User
	if err := initializers.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("user not found")
	}
	// Validate password
	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	// Generate JWT token
	token, err := auth.GenerateJWT(&user)
	if err != nil {
		return nil, errors.New("failed to generate token")
	}

	return &generated.AuthPayload{
		Token: token,
		User: &generated.User{
			UserID:   fmt.Sprintf("%d", user.ID),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Role:     user.Role,
			Password: user.Password,
		},
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	if input.Name == "" {
		return nil, fmt.Errorf("name is required")
	}
	if input.Email == "" {
		return nil, fmt.Errorf("email is required")
	}
	if input.Password == "" {
		return nil, fmt.Errorf("password is required")
	}
	if input.Role == "" {
		return nil, fmt.Errorf("role is required")
	}
	if input.Role != "ADMIN" && input.Role != "SALES_EXECUTIVE" && input.Role != "MANAGER" {
		return nil, fmt.Errorf("invalid role")
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if initializers.DB != nil {
		user := models.User{
			// ID:       uuid.NewString(),//gorm.Model has id field already set and is autoincremented
			GoogleId: *input.GoogleID,
			Name:     input.Name,
			Email:    input.Email,
			Phone:    *input.Phone,
			Password: string(hashedPassword),
			Role:     string(input.Role),
		}
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %v", err)
		}
		result := initializers.DB.Create(&user)
		if result.Error != nil {
			return nil, result.Error
		}
		return &generated.User{
			UserID:   fmt.Sprintf("%d", user.ID),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Password: user.Password,
			Role:     user.Role,
		}, nil
	}
	return nil, fmt.Errorf("database connection is nil")
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, input generated.UpdateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)

	fmt.Println("Role: ", role)

	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to update user")
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Update the user's fields with the input
	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Phone != nil {
		user.Phone = *input.Phone
	}
	if input.Role != nil {
		user.Role = string(*input.Role)
	}

	// Save the updated user record in the database
	if err := initializers.DB.Save(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	// Return the updated user
	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (*generated.User, error) {
	// panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to delete user")
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}
	fmt.Println("User found: ", user)
	// Delete the user record from the database
	if err := initializers.DB.Delete(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to delete user: %v", err)
	}
	fmt.Println("User deleted: ", user)
	// Return the deleted user
	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// CreateOrganization is the resolver for the createOrganization field.
func (r *mutationResolver) CreateOrganization(ctx context.Context, input generated.CreateOrganizationInput) (*generated.Organization, error) {
	// Create new organization model instance
	newOrganization := models.Organization{
		OrganizationName:    input.OrganizationName,
		OrganizationEmail:   input.OrganizationEmail,
		OrganizationWebsite: *input.OrganizationWebsite,
		City:                input.City,
		Country:             input.Country,
		NoOfEmployees:       input.NoOfEmployees,
		AnnualRevenue:       input.AnnualRevenue,
	}

	// Save to database
	if err := initializers.DB.Create(&newOrganization).Error; err != nil {
		log.Printf("Error creating organization: %v", err)
		return nil, fmt.Errorf("internal error: failed to create organization")
	}

	// Return the created organization
	return &generated.Organization{
		ID:                  fmt.Sprintf("%d", newOrganization.ID),
		OrganizationName:    newOrganization.OrganizationName,
		OrganizationEmail:   newOrganization.OrganizationEmail,
		OrganizationWebsite: &newOrganization.OrganizationWebsite,
		City:                newOrganization.City,
		Country:             newOrganization.Country,
		NoOfEmployees:       newOrganization.NoOfEmployees,
		AnnualRevenue:       newOrganization.AnnualRevenue,
	}, nil
}

// CreateCampaign is the resolver for the createCampaign field.
func (r *mutationResolver) CreateCampaign(ctx context.Context, input generated.CreateCampaignInput) (*generated.Campaign, error) {
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create campaign")
	}
	// Create new campaign
	newCampaign := models.Campaign{
		CampaignName:     input.CampaignName,
		CampaignCountry:  input.CampaignCountry,
		CampaignRegion:   input.CampaignRegion,
		IndustryTargeted: input.IndustryTargeted,
	}
	if err := initializers.DB.Create(&newCampaign).Error; err != nil {
		log.Printf("Error creating campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to create campaign")
	}
	return &generated.Campaign{
		CampaignID:       fmt.Sprintf("%d", newCampaign.ID),
		CampaignName:     newCampaign.CampaignName,
		CampaignCountry:  newCampaign.CampaignCountry,
		CampaignRegion:   newCampaign.CampaignRegion,
		IndustryTargeted: newCampaign.IndustryTargeted,
	}, nil
}

// AddUserToCampaign is the resolver for the addUserToCampaign field.
func (r *mutationResolver) AddUserToCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: AddUserToCampaign - addUserToCampaign"))

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to add user to campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}
	// Add user to campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Append(&user); err != nil {
		log.Printf("Error adding user to campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to add user to campaign")
	}
	return &generated.Campaign{
		CampaignID:       fmt.Sprintf("%d", campaign.ID),
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: fmt.Sprintf("%d", user.ID),
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// RemoveUserFromCampaign is the resolver for the removeUserFromCampaign field.
func (r *mutationResolver) RemoveUserFromCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserFromCampaign - removeUserFromCampaign"))
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to remove user from campaign")
	}

	// Check if user is part of the campaign
	var exists bool
	err = initializers.DB.Raw(
		"SELECT EXISTS(SELECT 1 FROM campaign_users WHERE user_id = ? AND campaign_id = ?)", userID, campaignID,
	).Scan(&exists).Error

	if err != nil {
		log.Printf("Error checking user in campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to check user in campaign")
	}

	if !exists {
		return nil, fmt.Errorf("user is not part of this campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}

	// Remove user from campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Delete(&user); err != nil {
		log.Printf("Error removing user from campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to remove user from campaign")

	}
	return &generated.Campaign{
		CampaignID:       fmt.Sprintf("%d", campaign.ID),
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: fmt.Sprintf("%d", user.ID),
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// CreateLead is the resolver for the createLead field.
func (r *mutationResolver) CreateLead(ctx context.Context, input generated.CreateLeadInput) (*generated.Lead, error) {
	// Check if LeadCreatedBy exists
	// var createdByUser models.User

	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	fmt.Println("User from JWT: ", jwtClaims)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}
	// Check if Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}
	// Check if Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	lead := models.Lead{
		LeadID:             uuid.New().String(),
		FirstName:          input.FirstName,
		LastName:           input.LastName,
		Email:              input.Email,
		LinkedIn:           input.LinkedIn,
		Country:            input.Country,
		Phone:              input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: input.InitialContactDate,
		LeadCreatedBy:      userID,
		LeadAssignedTo:     input.LeadAssignedTo,
		LeadStage:          input.LeadStage.String(),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     input.OrganizationID,
		CampaignID:         input.CampaignID,
	}

	// Save lead to DB
	if err := initializers.DB.Create(&lead).Error; err != nil {
		return nil, err
	}

	return &generated.Lead{
		LeadID:             lead.LeadID,
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: lead.InitialContactDate,
		LeadCreatedBy: &generated.User{
			UserID: userID,
		},
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", assignedToUser.ID),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			ID:               fmt.Sprintf("%d", organization.ID),
			OrganizationName: organization.OrganizationName,
		},

		Campaign: &generated.Campaign{
			CampaignID:   fmt.Sprintf("%d", campaign.ID),
			CampaignName: campaign.CampaignName,
		},
	}, nil
}

// UpdateLead is the resolver for the updateLead field.
func (r *mutationResolver) UpdateLead(ctx context.Context, leadID string, input generated.UpdateLeadInput) (*generated.Lead, error) {
	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}

	// Check if LeadStage is updated to "WON" from a different value
	isWon := input.LeadStage.String() == "CLOSED_WON" && lead.LeadStage != "CLOSED_WON"

	// Update Lead Details
	if err := initializers.DB.Model(&lead).Updates(models.Lead{
		FirstName:          *input.FirstName,
		LastName:           *input.LastName,
		Email:              input.Email,
		LinkedIn:           *input.LinkedIn,
		Country:            *input.Country,
		Phone:              *input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: input.InitialContactDate,
		LeadAssignedTo:     input.LeadAssignedTo,
		LeadStage:          input.LeadStage.String(),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     input.OrganizationID,
		CampaignID:         input.CampaignID,
	}).Error; err != nil {
		return nil, err
	}

	// If LeadStage is updated to "WON" and no existing deal, create a new deal
	if isWon {
		existingDeal := models.Deals{}
		if err := initializers.DB.Where("lead_id = ?", leadID).First(&existingDeal).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				// Create a new Deal only if it does not exist
				newDeal := models.Deals{
					LeadID:        leadID,
					DealName:      fmt.Sprintf("Deal for %s %s", lead.FirstName, lead.LastName),
					DealAmount:    "0", // Default, can be updated later
					DealStartDate: time.Now().String(),
					DealEndDate:   time.Now().AddDate(0, 6, 0).String(), // Example: 6 months duration
					DealStatus:    "Active",
				}
				if err := initializers.DB.Create(&newDeal).Error; err != nil {
					log.Printf("Error creating deal for lead %s: %v", leadID, err)
					return nil, fmt.Errorf("internal error: failed to create deal")
				}
			}
		}
	}

	return &generated.Lead{
		LeadID:             leadID,
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: lead.InitialContactDate,
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", lead.Assignee.ID),
			Name:   lead.Assignee.Name,
			Email:  lead.Assignee.Email,
			Phone:  lead.Assignee.Phone,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			ID:               lead.OrganizationID,
			OrganizationName: lead.Organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			CampaignID: lead.CampaignID,
		},
	}, nil
}

// DeleteLead is the resolver for the deleteLead field.
func (r *mutationResolver) DeleteLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: DeleteLead - deleteLead"))

	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&lead).Error; err != nil {
		return nil, err
	}
	return &generated.Lead{
		LeadID:    lead.LeadID,
		FirstName: lead.FirstName,
		LastName:  lead.LastName,
		Email:     lead.Email,
		LinkedIn:  lead.LinkedIn,
		Country:   lead.Country,
	}, nil
}

// CreateLeadWithActivity is the resolver for the createLeadWithActivity field.
func (r *mutationResolver) CreateLeadWithActivity(ctx context.Context, input generated.CreateLeadWithActivityInput) (*generated.Lead, error) {
	jwtClaims, _ := auth.GetUserFromJWT(ctx)

	fmt.Println("User from JWT: ", jwtClaims)
	// Validate LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}

	// Validate Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {

		fmt.Println("Organization id ", input.OrganizationID)

		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}

	// Validate Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		fmt.Println("Campaign id ", input.CampaignID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	// Create new lead instance
	newLead := models.Lead{
		LeadID:             uuid.NewString(),
		FirstName:          input.Firstname,
		LastName:           input.Lastname,
		Email:              input.Email,
		LinkedIn:           input.LinkedIn,
		Country:            input.Country,
		Phone:              input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: input.InitialContactDate,
		LeadCreatedBy:      userID,
		LeadAssignedTo:     input.LeadAssignedTo,
		LeadStage:          input.LeadStage.String(),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     input.OrganizationID,
		CampaignID:         input.CampaignID,
	}

	// Create new activity instance
	newActivity := models.Activity{
		ActivityID:           uuid.NewString(),
		LeadID:               newLead.LeadID, // Associate the activity with the lead
		ActivityType:         input.ActivityType,
		DateTime:             input.DateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}

	// Use a transaction to ensure both Lead and Activity are created successfully
	err := initializers.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(&newLead).Error; err != nil {
			log.Printf("Error creating lead: %v", err)
			return fmt.Errorf("internal error: failed to create lead")
		}

		if err := tx.Create(&newActivity).Error; err != nil {
			log.Printf("Error creating activity: %v", err)
			return fmt.Errorf("internal error: failed to create activity")
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	// Return the created lead and its associated activity
	return &generated.Lead{
		LeadID:             newLead.LeadID,
		FirstName:          newLead.FirstName,
		LastName:           newLead.LastName,
		Email:              newLead.Email,
		LinkedIn:           newLead.LinkedIn,
		Country:            newLead.Country,
		Phone:              newLead.Phone,
		LeadSource:         newLead.LeadSource,
		InitialContactDate: newLead.InitialContactDate,
		LeadCreatedBy: &generated.User{
			UserID: userID,
		},
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", assignedToUser.ID),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
		},
		LeadStage:    newLead.LeadStage,
		LeadNotes:    newLead.LeadNotes,
		LeadPriority: newLead.LeadPriority,
		Organization: &generated.Organization{
			ID:               fmt.Sprintf("%d", organization.ID),
			OrganizationName: organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			CampaignID:   fmt.Sprintf("%d", campaign.ID),
			CampaignName: campaign.CampaignName,
		},
		Activities: []*generated.Activity{
			{
				ActivityID:           newActivity.ActivityID,
				LeadID:               newActivity.LeadID,
				ActivityType:         newActivity.ActivityType,
				DateTime:             newActivity.DateTime,
				CommunicationChannel: newActivity.CommunicationChannel,
				ContentNotes:         newActivity.ContentNotes,
				ParticipantDetails:   newActivity.ParticipantDetails,
				FollowUpActions:      newActivity.FollowUpActions,
			},
		},
	}, nil
}

// CreateDeal is the resolver for the createDeal field.
func (r *mutationResolver) CreateDeal(ctx context.Context, input generated.CreateDealInput) (*generated.Deal, error) {
	// panic(fmt.Errorf("not implemented: CreateDeal - createDeal"))

	// Create new deal
	newDeal := models.Deals{
		LeadID:        input.LeadID,
		DealName:      input.DealName,
		DealAmount:    input.DealAmount,
		DealStartDate: input.DealStartDate,
		DealEndDate:   input.DealEndDate,
		DealStatus:    input.DealStatus.String(),
	}
	if err := initializers.DB.Create(&newDeal).Error; err != nil {
		log.Printf("Error creating deal: %v", err)
		return nil, fmt.Errorf("internal error: failed to create deal")
	}
	return &generated.Deal{
		DealID:     fmt.Sprintf("%d", newDeal.ID),
		LeadID:     newDeal.LeadID,
		DealName:   newDeal.DealName,
		DealAmount: newDeal.DealAmount,
		DealStatus: newDeal.DealStatus,
	}, nil
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input generated.CreateActivityInput) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: CreateActivity - createActivity"))
	log.Println("CreateActivity input parameters:", input.LeadID, input.ActivityType, input.DateTime, input.CommunicationChannel, input.ContentNotes, input.ParticipantDetails, input.FollowUpActions)

	// Create new activity
	newActivity := models.Activity{
		ActivityID:           uuid.NewString(),
		LeadID:               input.LeadID,
		ActivityType:         input.ActivityType,
		DateTime:             input.DateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}
	if err := initializers.DB.Create(&newActivity).Error; err != nil {
		log.Printf("Error creating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to create activity")
	}

	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID: newActivity.ActivityID,
		LeadID:     newActivity.LeadID,

		ActivityType:         newActivity.ActivityType,
		DateTime:             newActivity.DateTime,
		CommunicationChannel: newActivity.CommunicationChannel,
		ContentNotes:         newActivity.ContentNotes,
		ParticipantDetails:   newActivity.ParticipantDetails,
		FollowUpActions:      newActivity.FollowUpActions,
	}, nil
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, activityID string, input generated.UpdateActivityInput) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: UpdateActivity - updateActivity"))

	// Update activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	activity.ActivityType = *input.ActivityType
	activity.DateTime = *input.DateTime
	activity.CommunicationChannel = *input.CommunicationChannel
	activity.ContentNotes = *input.ContentNotes
	activity.ParticipantDetails = *input.ParticipantDetails
	activity.FollowUpActions = *input.FollowUpActions
	if err := initializers.DB.Save(&activity).Error; err != nil {
		log.Printf("Error updating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to update activity")
	}
	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           activity.ActivityID,
		LeadID:               activity.LeadID,
		ActivityType:         activity.ActivityType,
		DateTime:             activity.DateTime,
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, activityID string) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: DeleteActivity - deleteActivity"))
	// Delete activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&activity).Error; err != nil {
		log.Printf("Error deleting activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to delete activity")
	}
	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           activity.ActivityID,
		LeadID:               activity.LeadID,
		ActivityType:         activity.ActivityType,
		DateTime:             activity.DateTime,
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// CreateResourceProfile is the resolver for the createResourceProfile field.
func (r *mutationResolver) CreateResourceProfile(ctx context.Context, input generated.CreateResourceProfileInput) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: CreateResourceProfile - createResourceProfile"))
	resourceProfile := models.ResourceProfile{
		Type:            models.ResourceType(input.Type),
		FirstName:       input.FirstName,
		LastName:        input.LastName,
		TotalExperience: input.TotalExperience,
		Status:          models.ResourceStatus(input.Status),
	}

	if input.ContactInformation != "" {
		resourceProfile.ContactInformation = []byte(input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}
	if input.VendorID != nil && *input.VendorID != "" {
		vendorID, err := uuid.Parse(*input.VendorID)
		if err != nil {
			return nil, fmt.Errorf("invalid vendor ID: %w", err)
		}
		resourceProfile.VendorID = &vendorID
	}

	if len(input.SkillIds) > 0 {
		skills, err := utils.FetchSkills(input.SkillIds)
		if err != nil {
			return nil, err
		}
		resourceProfile.Skills = skills
	}

	if err := initializers.DB.Create(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to create resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		ID:                 resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		VendorID: func() *string {
			if resourceProfile.VendorID == nil {
				return nil
			}
			s := resourceProfile.VendorID.String()
			return &s
		}(),
		Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// UpdateResourceProfile is the resolver for the updateResourceProfile field.
func (r *mutationResolver) UpdateResourceProfile(ctx context.Context, id string, input generated.UpdateResourceProfileInput) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: UpdateResourceProfile - updateResourceProfile")) //
	resourceProfileID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", id)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	// Update fields using pointers to distinguish between not provided and zero values
	if input.Type != nil {
		resourceProfile.Type = models.ResourceType(*input.Type)
	}
	if input.FirstName != nil {
		resourceProfile.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		resourceProfile.LastName = *input.LastName
	}
	if input.TotalExperience != nil {
		resourceProfile.TotalExperience = *input.TotalExperience
	}
	if input.ContactInformation != nil {
		resourceProfile.ContactInformation = []byte(*input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}
	if input.Status != nil {
		resourceProfile.Status = models.ResourceStatus(*input.Status)
	}
	if input.VendorID != nil && *input.VendorID != "" {
		vendorID, err := uuid.Parse(*input.VendorID)
		if err != nil {
			return nil, fmt.Errorf("invalid vendor ID: %w", err)
		}
		resourceProfile.VendorID = &vendorID
	}

	if input.SkillIds != nil {
		skills, err := utils.FetchSkills(input.SkillIds)
		if err != nil {
			return nil, err
		}
		if err := initializers.DB.Model(&resourceProfile).Association("Skills").Replace(skills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to update resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		ID:                 resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		VendorID: func() *string {
			if resourceProfile.VendorID == nil {
				return nil
			}
			s := resourceProfile.VendorID.String()
			return &s
		}(),
		Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// DeleteResourceProfile is the resolver for the deleteResourceProfile field.
func (r *mutationResolver) DeleteResourceProfile(ctx context.Context, id string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: DeleteResourceProfile - deleteResourceProfile"))
	resourceProfileID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", id)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	if err := initializers.DB.Delete(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to delete resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		ID:                 resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		VendorID: func() *string {
			if resourceProfile.VendorID == nil {
				return nil
			}
			s := resourceProfile.VendorID.String()
			return &s
		}(),
		Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// CreateVendor is the resolver for the createVendor field.
func (r *mutationResolver) CreateVendor(ctx context.Context, input generated.CreateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: CreateVendor - createVendor"))
	vendor := models.Vendor{
		CompanyName:  input.CompanyName,
		Status:       models.VendorStatus(input.Status),       // Enum conversion
		PaymentTerms: models.PaymentTerms(input.PaymentTerms), // Enum conversion
		Address:      input.Address,
	}

	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many)
	if len(input.SkillIds) > 0 {
		var skills []models.Skill
		for _, skillIDStr := range input.SkillIds {
			skillID, err := uuid.Parse(skillIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid skill ID: %w", err)
			}
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillID).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			skills = append(skills, skill)
		}
		vendor.Skills = skills
	}

	if err := initializers.DB.Create(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to create vendor: %w", err)
	}
	return &generated.Vendor{
		ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// UpdateVendor is the resolver for the updateVendor field.
func (r *mutationResolver) UpdateVendor(ctx context.Context, id string, input generated.UpdateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: UpdateVendor - updateVendor"))
	vendorID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", vendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", id)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	if input.CompanyName != nil {
		vendor.CompanyName = *input.CompanyName
	}
	if input.Status != nil {
		vendor.Status = models.VendorStatus(*input.Status)
	}
	if input.PaymentTerms != nil {
		vendor.PaymentTerms = models.PaymentTerms(*input.PaymentTerms)
	}
	if input.Address != nil {
		vendor.Address = *input.Address
	}
	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many) - Replace existing skills.
	if input.SkillIds != nil {
		var newSkills []models.Skill
		for _, skillIDStr := range input.SkillIds {
			skillID, err := uuid.Parse(skillIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid skill ID: %w", err)
			}
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillID).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			newSkills = append(newSkills, skill)
		}
		if err := initializers.DB.Model(&vendor).Association("Skills").Replace(newSkills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to update vendor: %w", err)
	}
	return &generated.Vendor{
		ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// DeleteVendor is the resolver for the deleteVendor field.
func (r *mutationResolver) DeleteVendor(ctx context.Context, id string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: DeleteVendor - deleteVendor"))
	vendorID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.First(&vendor, "id = ?", vendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", id)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	// GORM's soft delete.  Use Unscoped() to permanently delete (if needed).
	if err := initializers.DB.Delete(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to delete vendor: %w", err)
	}

	return &generated.Vendor{
		ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*generated.User, error) {
	// panic(fmt.Errorf("not implemented: GetUsers - getUsers"))

	log.Println("GetUsers called")
	// Get all users from the database

	var users []models.User
	if err := initializers.DB.
		Joins("LEFT JOIN campaign_users ON users.id = campaign_users.user_id").
		Joins("LEFT JOIN campaigns ON campaign_users.campaign_id = campaigns.id").
		Preload("Campaigns").
		Find(&users).Error; err != nil {

		log.Printf("Error fetching users: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch users")
	}
	for _, user := range users {
		log.Printf("User: %s, Campaign Count: %d", user.Name, len(user.Campaigns))
		for _, campaign := range user.Campaigns {
			log.Printf(" - Campaign: %s", campaign.CampaignName)
		}
	}
	for _, user := range users {
		log.Printf("User: %s, Campaigns: %v", user.Name, user.Campaigns)
	}

	// Map the users to the GraphQL response type
	var result []*generated.User
	for _, c := range users {
		var campaigns []*generated.Campaign
		for _, u := range c.Campaigns {
			campaigns = append(campaigns, &generated.Campaign{
				CampaignID:       fmt.Sprintf("%d", u.ID),
				CampaignName:     u.CampaignName,
				CampaignCountry:  u.CampaignCountry,
				CampaignRegion:   u.CampaignRegion,
				IndustryTargeted: u.IndustryTargeted,
			})
		}
		result = append(result, &generated.User{
			UserID:    fmt.Sprintf("%d", c.ID),
			GoogleID:  &c.GoogleId,
			Name:      c.Name,
			Email:     c.Email,
			Phone:     c.Phone,
			Role:      c.Role,
			Password:  c.Password,
			Campaigns: campaigns,
		})
	}

	return result, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*generated.User, error) {
	// Find the user by ID and preload campaigns
	var user models.User
	if err := initializers.DB.Preload("Campaigns").First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Map campaigns
	var campaigns []*generated.Campaign
	for _, c := range user.Campaigns {
		campaigns = append(campaigns, &generated.Campaign{
			CampaignID:       fmt.Sprintf("%d", c.ID),
			CampaignName:     c.CampaignName,
			CampaignCountry:  c.CampaignCountry,
			CampaignRegion:   c.CampaignRegion,
			IndustryTargeted: c.IndustryTargeted,
		})
	}

	// Map the user to the GraphQL response type
	return &generated.User{
		UserID:    fmt.Sprintf("%d", user.ID),
		GoogleID:  &user.GoogleId,
		Name:      user.Name,
		Email:     user.Email,
		Phone:     user.Phone,
		Role:      user.Role,
		Password:  user.Password,
		Campaigns: campaigns, // Include campaigns in response
	}, nil
}

// GetCampaigns is the resolver for the getCampaigns field.
func (r *queryResolver) GetCampaigns(ctx context.Context) ([]*generated.Campaign, error) {
	// func (r *queryResolver) GetCampaigns(ctx context.Context) ([]*generated.Campaign, error) {
	// Check user role
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to view campaigns")
	}
	var campaigns []models.Campaign

	// Load campaigns along with associated users
	if err := initializers.DB.Preload("Users").Find(&campaigns).Error; err != nil {
		log.Printf("Error fetching campaigns: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch campaigns")
	}

	// Convert models.Campaign to generated.Campaign
	var result []*generated.Campaign
	for _, c := range campaigns {
		var users []*generated.User
		for _, u := range c.Users {
			users = append(users, &generated.User{
				UserID: fmt.Sprintf("%d", u.ID),
				Name:   u.Name,
				Email:  u.Email,
				Phone:  u.Phone,
			})
		}
		result = append(result, &generated.Campaign{
			CampaignID:       fmt.Sprintf("%d", c.ID),
			CampaignName:     c.CampaignName,
			CampaignCountry:  c.CampaignCountry,
			CampaignRegion:   c.CampaignRegion,
			IndustryTargeted: c.IndustryTargeted,
			Users:            users, // Include users in the response
		})
	}

	return result, nil
}

// GetCampaign is the resolver for the getCampaign field.
func (r *queryResolver) GetCampaign(ctx context.Context, campaignID string) (*generated.Campaign, error) {
	panic(fmt.Errorf("not implemented: GetCampaign - getCampaign"))
}

// GetAllLeads is the resolver for the getAllLeads field.
func (r *queryResolver) GetAllLeads(ctx context.Context) ([]*generated.Lead, error) {
	if _, err := initializers.DB.DB(); err != nil {
		log.Fatalf("Database connection error: %v", err)
	} else {
		log.Println("Database connected successfully:")
	}

	var leads []models.Lead

	// Fetch all leads from the database
	// 	initializers.DB.Find(&leads):
	// Fetches all records from the leads table and stores them in the leads slice.
	// Preload("Activities"):
	// Eagerly loads the associated Activities for each lead (to avoid separate queries for activities).
	// Ensures that the lead.Activities field is populated when leads are fetched.
	// Preload("Organization"):
	// Eagerly loads the associated Organization for each lead.
	// Ensures that the lead.Organization field is populated when leads are fetched.
	// Preload("Campaign"):
	// Eagerly loads the associated Campaign for each lead.
	// Ensures that the lead.Campaign field is populated when leads are fetched.
	// Preload("User"):
	// Eagerly loads the associated User for each lead.
	// Ensures that the lead.User field is populated when leads are fetched.
	if err := initializers.DB.
		Preload("Activities").
		Preload("Organization").
		Preload("Campaign").
		Preload("Creator").
		Preload("Assignee").
		Find(&leads).Error; err != nil {
		log.Printf("Error fetching leads: %v", err)
	}

	// Map the leads from the database model to the GraphQL response type
	var result []*generated.Lead
	for _, lead := range leads {
		// For each lead, fetch its activities
		var activities []*generated.Activity
		for _, activity := range lead.Activities {
			activities = append(activities, &generated.Activity{
				ActivityID:           activity.ActivityID,
				LeadID:               activity.LeadID,
				ActivityType:         activity.ActivityType,
				DateTime:             activity.DateTime,
				CommunicationChannel: activity.CommunicationChannel,
				ContentNotes:         activity.ContentNotes,
				ParticipantDetails:   activity.ParticipantDetails,
				FollowUpActions:      activity.FollowUpActions,
			})
		}

		// Map Organization
		var organization *generated.Organization
		if lead.OrganizationID != "" {
			organization = &generated.Organization{
				ID:               fmt.Sprintf("%d", lead.Organization.ID),
				OrganizationName: lead.Organization.OrganizationName,
			}
		}

		// Map Campaign
		var campaign *generated.Campaign
		if lead.CampaignID != "" {
			campaign = &generated.Campaign{
				CampaignID:       fmt.Sprintf("%d", lead.Campaign.ID),
				CampaignName:     lead.Campaign.CampaignName,
				CampaignCountry:  lead.Campaign.CampaignCountry,
				CampaignRegion:   lead.Campaign.CampaignRegion,
				IndustryTargeted: lead.Campaign.IndustryTargeted,
			}
		}

		fmt.Println("creator:", lead.Creator.ID)
		fmt.Println("assignee:", lead.Assignee.ID)

		result = append(result, &generated.Lead{
			LeadID:     lead.LeadID,
			FirstName:  lead.FirstName,
			LastName:   lead.LastName,
			LinkedIn:   lead.LinkedIn,
			Country:    lead.Country,
			Phone:      lead.Phone,
			LeadSource: lead.LeadSource,
			LeadCreatedBy: &generated.User{
				UserID: fmt.Sprintf("%d", lead.Creator.ID),
			},
			LeadAssignedTo: &generated.User{
				UserID: fmt.Sprintf("%d", lead.Assignee.ID),
			},
			LeadStage:          lead.LeadStage,
			LeadPriority:       lead.LeadPriority,
			LeadNotes:          lead.LeadNotes,
			InitialContactDate: lead.InitialContactDate,
			Activities:         activities,
			Organization:       organization,
			Campaign:           campaign,
		})

	}
	return result, nil
}

// GetOneLead is the resolver for the getOneLead field.
func (r *queryResolver) GetOneLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	role, _ := auth.GetUserRoleFromJWT(ctx)
	if role == "" {
		fmt.Println("Role is empty")
		return nil, fmt.Errorf("missing token")
	}

	// Find the lead by ID
	var lead models.Lead
	if err := initializers.DB.Preload("Activities").Preload("Organization").Preload("Campaign").First(&lead, "lead_id = ?", leadID).Error; err != nil {
		return nil, err
	}

	// Map the lead to the GraphQL response type
	var activities []*generated.Activity
	for _, activity := range lead.Activities {
		activities = append(activities, &generated.Activity{
			ActivityID:           activity.ActivityID,
			LeadID:               activity.LeadID,
			ActivityType:         activity.ActivityType,
			DateTime:             activity.DateTime,
			CommunicationChannel: activity.CommunicationChannel,
			ContentNotes:         activity.ContentNotes,
			ParticipantDetails:   activity.ParticipantDetails,
		})
	}

	// Map Organization
	var organization *generated.Organization
	if lead.OrganizationID != "" {
		organization = &generated.Organization{
			ID:               fmt.Sprintf("%d", lead.Organization.ID),
			OrganizationName: lead.Organization.OrganizationName,
		}
	}

	// Map Campaign
	var campaign *generated.Campaign
	if lead.CampaignID != "" {
		campaign = &generated.Campaign{
			CampaignID:       fmt.Sprintf("%d", lead.Campaign.ID),
			CampaignName:     lead.Campaign.CampaignName,
			CampaignCountry:  lead.Campaign.CampaignCountry,
			CampaignRegion:   lead.Campaign.CampaignRegion,
			IndustryTargeted: lead.Campaign.IndustryTargeted,
		}
	}

	// Map the lead to the GraphQL response type
	return &generated.Lead{
		LeadID:     lead.LeadID,
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		// LeadCreatedBy:      lead.LeadCreatedBy,
		// LeadAssignedTo:     lead.LeadAssignedTo,
		LeadStage:          lead.LeadStage,
		LeadPriority:       lead.LeadPriority,
		LeadNotes:          lead.LeadNotes,
		InitialContactDate: lead.InitialContactDate,
		Activities:         activities,
		Organization:       organization,
		Campaign:           campaign,
	}, nil
}

// Me is the resolver for the me field. To check the Connection and JWT Authentication
func (r *queryResolver) Me(ctx context.Context) (*generated.User, error) {
	claims, ok := auth.GetUserFromJWT(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	var user models.User
	if err := initializers.DB.First(&user, "id = ?", claims["user_id"]).Error; err != nil {
		return nil, errors.New("user not found")
	}

	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Role:     user.Role,
	}, nil
	// panic(fmt.Errorf("not implemented: Me - me"))
}

// GetOrganizations is the resolver for the getOrganizations field.
func (r *queryResolver) GetOrganizations(ctx context.Context) ([]*generated.Organization, error) {
	panic(fmt.Errorf("not implemented: GetOrganizations - getOrganizations"))
}

// GetOrganizationByID is the resolver for the getOrganizationByID field.
func (r *queryResolver) GetOrganizationByID(ctx context.Context, id string) (*generated.Organization, error) {
	panic(fmt.Errorf("not implemented: GetOrganizationByID - getOrganizationByID"))
}

// GetResourceProfiles is the resolver for the getResourceProfiles field.
func (r *queryResolver) GetResourceProfiles(ctx context.Context, filter *generated.ResourceProfileFilter, pagination *generated.PaginationInput, sort *generated.ResourceProfileSortInput) (*generated.ResourceProfilePage, error) {
	// panic(fmt.Errorf("not implemented: GetResourceProfiles - getResourceProfiles"))
	var resourceProfiles []models.ResourceProfile
	var totalCount int64

	db := initializers.DB.Model(&models.ResourceProfile{})

	// Apply filtering
	if filter != nil {
		if filter.Type != nil {
			db = db.Where("type = ?", *filter.Type)
		}
		if filter.FirstName != nil {
			db = db.Where("first_name ILIKE ?", "%"+*filter.FirstName+"%")
		}
		if filter.LastName != nil {
			db = db.Where("last_name ILIKE ?", "%"+*filter.LastName+"%")
		}
		if filter.TotalExperienceMin != nil {
			db = db.Where("total_experience >= ?", *filter.TotalExperienceMin)
		}
		if filter.TotalExperienceMax != nil {
			db = db.Where("total_experience <= ?", *filter.TotalExperienceMax)
		}
		if filter.Status != nil {
			db = db.Where("status = ?", *filter.Status)
		}
		if filter.VendorID != nil {
			db = db.Where("vendor_id = ?", *filter.VendorID)
		}
		if filter.Search != nil {
			searchPattern := "%" + *filter.Search + "%"
			db = db.Where(
				"first_name ILIKE ? OR last_name ILIKE ? OR EXISTS (SELECT 1 FROM vendors WHERE vendors.id = resource_profiles.vendor_id AND vendors.company_name ILIKE ?)",
				searchPattern, searchPattern, searchPattern,
			)
		}
		if len(filter.SkillIds) > 0 {
			// Join with the resource_skills table and filter by skill IDs
			db = db.Joins("JOIN resource_skills ON resource_skills.resource_profile_id = resource_profiles.id").
				Where("resource_skills.skill_id IN ?", filter.SkillIds)
		}
	}
	// Apply sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.ResourceProfileSortFieldCreatedAt:
			db = db.Order("created_at " + sortOrder)
		case generated.ResourceProfileSortFieldUpdatedAt:
			db = db.Order("updated_at " + sortOrder)
		case generated.ResourceProfileSortFieldFirstName:
			db = db.Order("first_name " + sortOrder)
		case generated.ResourceProfileSortFieldLastName:
			db = db.Order("last_name " + sortOrder)
		case generated.ResourceProfileSortFieldTotalExperience:
			db = db.Order("total_experience " + sortOrder)
		case generated.ResourceProfileSortFieldStatus:
			db = db.Order("status " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		db = db.Order("created_at desc")
	}

	// Count total records before applying limit/offset for pagination
	db.Count(&totalCount)
	// Apply pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := db.Preload("Skills").Preload("Vendor").Find(&resourceProfiles).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve resource profiles: %w", err)
	}

	// Convert to generated type
	generatedProfiles := make([]*generated.ResourceProfile, len(resourceProfiles))
	for i, profile := range resourceProfiles {

		//convert pastProjects
		var generatedPastProjects []*generated.PastProject

		generatedProfiles[i] = &generated.ResourceProfile{
			ID:                 profile.ID.String(),
			Type:               generated.ResourceType(profile.Type),
			FirstName:          profile.FirstName,
			LastName:           profile.LastName,
			TotalExperience:    profile.TotalExperience,
			Status:             generated.ResourceStatus(profile.Status),
			ContactInformation: string(profile.ContactInformation),
			GoogleDriveLink:    profile.GoogleDriveLink,
			VendorID: func() *string {
				if profile.VendorID == nil {
					return nil
				}
				s := profile.VendorID.String()
				return &s
			}(),
			Vendor: func() *generated.Vendor { // Handle Vendor conversion
				if profile.Vendor == nil {
					return nil
				}
				return &generated.Vendor{
					ID:          profile.Vendor.ID.String(),
					CompanyName: profile.Vendor.CompanyName,
					Status:      generated.VendorStatus(profile.Vendor.Status),
					// ... other Vendor fields ...
					//convert skills
					Skills: []*generated.Skill{},
					//convert contact list
					ContactList: []*generated.Contact{},
					//convert performance ratings
					PerformanceRatings: []*generated.PerformanceRating{},
					//convert resources
					Resources: []*generated.ResourceProfile{},
				}
			}(),
			Skills:       utils.ConvertSkills(profile.Skills), // Use the helper function
			PastProjects: generatedPastProjects,
		}
	}

	return &generated.ResourceProfilePage{
		Items:      generatedProfiles,
		TotalCount: int32(totalCount),
	}, nil
}

// GetVendors is the resolver for the getVendors field.
func (r *queryResolver) GetVendors(ctx context.Context, filter *generated.VendorFilter, pagination *generated.PaginationInput, sort *generated.VendorSortInput) (*generated.VendorPage, error) {
	// panic(fmt.Errorf("not implemented: GetVendors - getVendors"))
	var vendors []models.Vendor
	var totalCount int64

	db := initializers.DB.Model(&models.Vendor{})

	// Apply filtering
	if filter != nil {
		if filter.CompanyName != nil {
			db = db.Where("company_name ILIKE ?", "%"+*filter.CompanyName+"%")
		}
		if filter.Status != nil {
			db = db.Where("status = ?", *filter.Status)
		}
		if filter.PaymentTerms != nil {
			db = db.Where("payment_terms = ?", *filter.PaymentTerms)
		}
		if filter.Search != nil {
			searchPattern := "%" + *filter.Search + "%"
			db = db.Where("company_name ILIKE ? OR address ILIKE ?", searchPattern, searchPattern)
		}
		if len(filter.SkillIds) > 0 {
			db = db.Joins("JOIN vendor_skills ON vendor_skills.vendor_id = vendors.id").
				Where("vendor_skills.skill_id IN ?", filter.SkillIds)
		}
	}

	// Apply sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.VendorSortFieldCreatedAt:
			db = db.Order("created_at " + sortOrder)
		case generated.VendorSortFieldUpdatedAt:
			db = db.Order("updated_at " + sortOrder)
		case generated.VendorSortFieldCompanyName:
			db = db.Order("company_name " + sortOrder)
		case generated.VendorSortFieldStatus:
			db = db.Order("status " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		db = db.Order("created_at desc")
	}

	// Count total records before applying limit/offset for pagination
	db.Count(&totalCount)

	// Apply pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := db.Preload("Skills").Find(&vendors).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve vendors: %w", err)
	}

	// Convert to generated type
	generatedVendors := make([]*generated.Vendor, len(vendors))
	for i, vendor := range vendors {
		//convert skills
		var generatedSkills []*generated.Skill
		//convert contact list
		var generatedContactList []*generated.Contact
		//convert performance ratings
		var generatedPerformanceRatings []*generated.PerformanceRating
		//convert resources
		var generatedResources []*generated.ResourceProfile

		generatedVendors[i] = &generated.Vendor{
			ID:                 vendor.ID.String(),
			CompanyName:        vendor.CompanyName,
			Status:             generated.VendorStatus(vendor.Status),
			PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
			Address:            vendor.Address,
			GstOrVatDetails:    vendor.GstOrVatDetails,
			Notes:              vendor.Notes,
			Skills:             generatedSkills,
			ContactList:        generatedContactList,
			PerformanceRatings: generatedPerformanceRatings,
			Resources:          generatedResources,
		}
	}

	return &generated.VendorPage{
		Items:      generatedVendors,
		TotalCount: int32(totalCount),
	}, nil
}

// GetResourceProfile is the resolver for the getResourceProfile field.
func (r *queryResolver) GetResourceProfile(ctx context.Context, id string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: GetResourceProfile - getResourceProfile"))
	resourceProfileID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").Preload("Vendor").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", id)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	//convert pastProjects
	var generatedPastProjects []*generated.PastProject

	return &generated.ResourceProfile{
		ID:                 resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		VendorID: func() *string {
			if resourceProfile.VendorID == nil {
				return nil
			}
			s := resourceProfile.VendorID.String()
			return &s
		}(),
		Vendor: func() *generated.Vendor { // Handle the nested Vendor conversion
			if resourceProfile.Vendor == nil {
				return nil
			}
			return &generated.Vendor{
				ID:          resourceProfile.Vendor.ID.String(),
				CompanyName: resourceProfile.Vendor.CompanyName,
				Status:      generated.VendorStatus(resourceProfile.Vendor.Status),
				// ... other Vendor fields ...
				//convert skills
				Skills: []*generated.Skill{},
				//convert contact list
				ContactList: []*generated.Contact{},
				//convert performance ratings
				PerformanceRatings: []*generated.PerformanceRating{},
				//convert resources
				Resources: []*generated.ResourceProfile{},
			}
		}(),
		Skills:       utils.ConvertSkills(resourceProfile.Skills), // Convert skills
		PastProjects: generatedPastProjects,
	}, nil
}

// GetVendor is the resolver for the getVendor field.
func (r *queryResolver) GetVendor(ctx context.Context, id string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: GetVendor - getVendor"))
	vendorID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", vendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", id)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	//convert skills
	var generatedSkills []*generated.Skill
	//convert contact list
	var generatedContactList []*generated.Contact
	//convert performance ratings
	var generatedPerformanceRatings []*generated.PerformanceRating
	//convert resources
	var generatedResources []*generated.ResourceProfile
	return &generated.Vendor{
		ID:                 vendor.ID.String(),
		CompanyName:        vendor.CompanyName,
		Status:             generated.VendorStatus(vendor.Status),
		PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
		Address:            vendor.Address,
		GstOrVatDetails:    vendor.GstOrVatDetails,
		Notes:              vendor.Notes,
		Skills:             generatedSkills,
		ContactList:        generatedContactList,
		PerformanceRatings: generatedPerformanceRatings,
		Resources:          generatedResources,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
